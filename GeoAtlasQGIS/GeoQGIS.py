# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoQGIS
                                 A QGIS plugin
 GeoQGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-01-21
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Geo
        email                : hmd@geo.dk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from venv import create
import requests
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtSvg import QSvgWidget, QSvgRenderer
from PyQt5.QtWebKitWidgets import QWebView
# Initialize Qt resources from file resources.py

import time
from qgis.gui import *
from qgis.core import *
from operator import itemgetter
import os
import locale
import ctypes
import urllib.parse
import tempfile
from threading import Thread
import re
import xml.etree.ElementTree as ET

from .utils import *
from .virtualBoring import *
from .ApiKeyGetter import *
from .SliceTool import *
from .resources import *
from .Crosssection import *
from .report import *
import threading
import json


class GeoQGIS:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        # Used for finding files in the directory.
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        # Currently unused, but useful if we start translating.
        # locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeoQGIS_{}.qm'.format("en"))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        self.settings = Settings()
        self.settings.settings_updated.connect(self.reloadMenu)
        self.options_factory = OptionsFactory(self.settings)
        self.options_factory.setTitle(self.tr('GeoAtlas'))
        iface.registerOptionsWidgetFactory(self.options_factory)
        iface.mapCanvas().setPreviewJobsEnabled(False)
       

        # Declare instance attributes
        # Actions for action bar
        self.actions = []
        self.menu = self.tr(u'&GeoQGIS')
        self.layersMenu = None
        self.hydromodelsMenu = None
        self.currentModels = None
        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        for i in range(10):
            debugMsg("")
        debugMsg("Loaded plugin")
        self.first_start = None
        self.svgWidget = None
        self.modelid = 0 
        self.apiKeyGetter = ApiKeyGetter(self.iface, self.settings)
        self.apiKey = self.apiKeyGetter.getApiKey()
        self.elemdict = None
        self._capabilities_cache = {}
        if self.apiKey is not None:
            self.addModelsToMap(createonlyfile=True)
            self.createElemDict()
        self.virtualBoring = VirtualBoringTool(self.iface, self.elemdict, self.apiKeyGetter, self.settings)
        self.sliceTool = SliceTool(self.iface, self.elemdict, self.apiKeyGetter, self.settings)
        self.crosssectionTool = Crosssection(self.iface, self.elemdict, self.apiKeyGetter, self.settings)
        self.report = ReportTool(self.iface, self.apiKeyGetter)
        # Timer is used for regularly updating tokens and keeping access to 
        # wms layers as the tokens only last for 22 hours.
        self.register_timer_for_token_updater()
        self.update_GAL_layers_with_tokens()
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeoQGIS', message)

    def register_timer_for_token_updater(self):
        # When we load a new project, update the tokens in it.
        self.iface.projectRead.connect(self.update_token_on_project_load)
        self.timer = QTimer()
        
        self.timer.timeout.connect(self.update_GAL_layers_with_tokens)
        self.timer.start(1000 * 60 * 30) #Is in miliseconds. So runs every half hour
        # Should be okay as it last for 22 hours.

    def update_token_on_project_load(self):
        # Wait for 10 seconds before updating tokens, as it seems doing it while loading 
        # makes QGIS crash.
        self.timer.singleShot(10000, self.update_GAL_layers_with_tokens)

    def makeMenu(self):
        # Tool bar menu.
        self.menu = QMenu( "GeoAtlas", self.iface.mainWindow().menuBar() )
        actions = self.iface.mainWindow().menuBar().actions()
        lastAction = actions[-1]
        self.iface.mainWindow().menuBar().insertMenu( lastAction, self.menu )
        self.menu.addAction( 'Add models to map', self.addModelsToMap)
        #self.menu.addAction( 'Print Api Key', self.apiKeyGetter.printApiKey)
        self.menu.addAction( 'Add Boreholes to map', lambda: self.addLayer("GAL - Boreholes", "borehole", "borehole-labels"))
        self.hydromodelsMenu = QMenu('Add hydromodels to map', self.menu)
        self.menu.addMenu(self.hydromodelsMenu)
        self.populateHydromodelsMenu(self.hydromodelsMenu)
        # Create nested submenu for adding layers
        # We'll set the title with count after populating
        self.layersMenu = QMenu('Add layers to map', self.menu)
        self.menu.addMenu(self.layersMenu)
        
        # Populate the layers menu
        self.populateLayersMenu(self.layersMenu)
        self.menu.addAction('Refresh hydromodel catalogue', self.refreshHydromodelsMenu)
        self.menu.addAction('Refresh layer catalogue', self.refreshLayersMenu)

        self.menu.addAction( 'Update Tokens', self.update_GAL_layers_with_tokens)
        self.menu.addAction( 'Help', self.helpmessagebox)
        self.menu.addAction( 'About', self.aboutmessagebox)

        self.myToolBar = self.iface.mainWindow().findChild( QToolBar, u'GeoAtlasToolBar' )
        if not self.myToolBar:
            self.myToolBar = self.iface.addToolBar( u'GeoAtlasToolBar' )
            self.myToolBar.setObjectName( u'GeoAtlasToolBar' )

        self.myToolBar.clear()
        self.addActionsToActionBar()
        # add toolbar button and menu item


    def populateLayersMenu(self, layersMenu):
        layer_group_order = {
            #0: 'Baggrundskort',
            1: 'DHM kort og kurver', 2: 'Boringer og geofysik',
            3: 'Danmarks undergrund', 4: 'Overfladenære og geotekniske kort', 5: 'Miljø',
            9: 'Terrænnært grundvand', 6: 'Vand', 10: 'Satellit', 7: 'Forvaltning',
            11: 'Andre baggrundskort', 8: 'Andre'
        }
        
        base_url = self.settings.get_geo_base_url()
        configUrl = f'{base_url}/api/v3/user/config?geoAreaid=1'
        key = self.apiKeyGetter.getApiKey()
        
        res = requests.get(configUrl, headers={'authorization': key})
        if res.status_code != 200:
            debugMsg("Failed to get config for layers menu: " + str(res.status_code))
            return
        
        res_json = res.json()
        layers = res_json.get('MapLayers', [])
        layers = [l for l in layers if l.get('Enabled', False)]
        
        self._buildLayerMenu(layersMenu, layers, layer_group_order)
    
    def _buildLayerMenu(self, target_menu, layers, group_order):
        # boolean indicates whether the URL is "available" (unavailable is grayed out in menu)
        custom_urls = {
            '%geusurl%': ("https://data.geus.dk/geusmap/ows/25832.jsp?whoami=data@geo.dk", True),
            '%dafurl%': ("https://services.datafordeler.dk/", True),
            '%kfurl%': ("https://api.dataforsyningen.dk/", True),
            '%dkmiljoeportalurl%': ("https://arealeditering-dist-geo.miljoeportal.dk/", True),
            '%dkmiljoegisurl%': ("https://miljoegis.mim.dk/wms", True)
        }
        
        def is_layer_invalid(layername):
            if not layername:
                return True
            suffix = str(layername).split(':')[-1] if ':' in layername else layername
            invalid = suffix.lower() in ['[empty]', 'none', '']
            return invalid
        
        def count_layer_styles(layer):
            map_layer_styles = layer.get('MapLayerStyles', [])
            count = len(map_layer_styles) if map_layer_styles else 0
            style = layer.get('Style', '')
            if style:
                suffixed = str(style).strip().split(':')[-1] if ':' in style else style
                if suffixed.lower() not in ['none', '[empty]']:
                    count += 1
            return max(count, 1)
        
        def add_layer_menu_item(menu, layer):
            layername = (layer.get('LayerName', '') or '').strip()
            custom_url = layer.get('Url', None)
            url_is_available = True
            if custom_url:
                for key, (replacement_url, is_available) in custom_urls.items():
                    if key in custom_url:
                        custom_url = custom_url.replace(key, replacement_url)
                        if not is_available:
                            url_is_available = False
                            break
            
            if is_layer_invalid(layername) or not url_is_available:
                if not url_is_available:
                    debugMsg("Layer URL unavailable: '" + layer.get('Name', 'Unnamed Layer') + "'. Marking as unavailable.")
                else:
                    debugMsg("Layer name '" + layername + "' invalid for layer '" + layer.get('Name', 'Unnamed Layer') + "'. Marking as unavailable.")
                action = menu.addAction(layer.get('Name', 'Unavngivet Lag') + " - Utilgængelig i QGIS plugin!")
                action.setEnabled(False)
                return
            
            map_layer_styles = layer.get('MapLayerStyles', [])
            base_style = (layer.get('Style', '') or '').strip()
            has_valid_base_style = base_style and base_style.lower() not in ['none', '[empty]']
            
            if map_layer_styles:
                layer_name = layer.get('Name', 'Unavngivet Lag')
                count = len(map_layer_styles) + (1 if has_valid_base_style else 0)
                styleSubmenu = QMenu(f"{layer_name} ({count})", menu)
                
                if has_valid_base_style:
                    processed_style = base_style
                    styleSubmenu.addAction(layer_name, lambda t=layer_name, ln=layername, s=processed_style, url=custom_url: self.addLayer(t, ln, s, url))
                
                for style_entry in map_layer_styles:
                    style_title = style_entry.get('DisplayName', style_entry.get('Name', 'Unavngivet Stil'))
                    style_name = (style_entry.get('Name', '') or '').strip()
                    styleSubmenu.addAction(style_title, lambda t=style_title, ln=layername, s=style_name, url=custom_url: self.addLayer(t, ln, s, url))
                
                menu.addMenu(styleSubmenu)
            else:
                title = layer.get('Name', 'Unavngivet Lag')
                style = (layer.get('Style', '') or '').strip()
                if custom_url and custom_url.startswith('%'):
                    title += " - ⚠️Unfixed External Url⚠️"
                menu.addAction(title, lambda t=title, ln=layername, s=style, url=custom_url: self.addLayer(t, ln, s, url))
        
        layer_groups = {}
        for layer in layers:
            layer_group_id = layer.get('LayerGroup', 8)
            if layer_group_id not in layer_groups:
                layer_groups[layer_group_id] = []
            layer_groups[layer_group_id].append(layer)
        
        total_count = 0
        for group_id in group_order.keys():
            if group_id not in layer_groups:
                continue
            
            group_layers = layer_groups[group_id]
            group_name = group_order.get(group_id, str(group_id))
            
            subgroups = {}
            no_subgroup = []
            for layer in group_layers:
                group_name_attr = layer.get('GroupName')
                if group_name_attr:
                    subgroups.setdefault(group_name_attr, []).append(layer)
                else:
                    no_subgroup.append(layer)
            
            group_count = sum(count_layer_styles(l) for l in group_layers)
            total_count += group_count
            
            groupSubmenu = QMenu(f"{group_name} ({group_count})", target_menu)
            target_menu.addMenu(groupSubmenu)
            
            for layer in no_subgroup:
                add_layer_menu_item(groupSubmenu, layer)
            
            for subgroup_name, subgroup_layers in subgroups.items():
                subgroup_count = sum(count_layer_styles(l) for l in subgroup_layers)
                subgroupSubmenu = QMenu(f"{subgroup_name} ({subgroup_count})", groupSubmenu)
                groupSubmenu.addMenu(subgroupSubmenu)
                
                for layer in subgroup_layers:
                    add_layer_menu_item(subgroupSubmenu, layer)
        
        target_menu.setTitle(f"Add layers to map ({total_count})")


    def populateHydromodelsMenu(self, hydromodelsMenu):
        hydromodelsMenu.clear()
        hydromodelsMenu.setTitle('Add hydromodels to map')

        api_key = self.apiKeyGetter.getApiKey()
        if api_key is None:
            action = hydromodelsMenu.addAction('Login required to load hydromodels')
            action.setEnabled(False)
            return
        
        base_url = self.settings.get_geo_base_url()
        url = self._ensure_auth(f"{base_url}/mapv2/geo-hydromodels/wms")

        try:
            response = requests.get(
                f'{base_url}/api/v3/hydromodel?geoareaid=1',
                headers={'authorization': api_key},
                timeout=10
            )
        except requests.RequestException as exc:
            debugMsg(f"Failed to fetch hydromodels: {exc}")
            action = hydromodelsMenu.addAction('Unable to load hydromodel catalogue')
            action.setEnabled(False)
            return

        if response.status_code != 200:
            debugMsg("Failed to fetch hydromodels: " + str(response.status_code))
            action = hydromodelsMenu.addAction(f"Unable to load hydromodels (HTTP {response.status_code})")
            action.setEnabled(False)
            return

        try:
            payload = response.json()
        except ValueError as exc:
            debugMsg(f"Failed to parse hydromodel response: {exc}")
            action = hydromodelsMenu.addAction('Unable to parse hydromodel data')
            action.setEnabled(False)
            return

        models = payload

        grouped_entries = {}
        total_models = 0
        for model in models:
            if not isinstance(model, dict):
                continue
            group_name = (model.get('Name') or '').strip()
            if not group_name:
                group_name = 'Other hydromodels'
            long_name = (model.get('LongName') or '').strip()
            if not long_name:
                continue
            model_id = model.get('Id')
            if model_id in (None, ''):
                continue
            layer_names = []
            layer_index = 1
            while True:
                key = f'WMSLayerName{layer_index}'
                if key not in model:
                    break
                raw_name = (model.get(key) or '').strip()
                if not raw_name:
                    break
                normalized = self._normalize_layer_name(url, raw_name, silent=True) or raw_name
                if normalized and normalized not in layer_names:
                    layer_names.append(normalized)
                layer_index += 1
            if not layer_names:
                continue
            grouped_entries.setdefault(group_name, []).append((long_name, tuple(layer_names), model_id))
            total_models += 1

        if not grouped_entries:
            action = hydromodelsMenu.addAction('No hydromodel layers available')
            action.setEnabled(False)
            return

        hydromodelsMenu.setTitle(f"Add hydromodels to map ({total_models})")

        for group_name in sorted(grouped_entries.keys(), key=lambda name: name.lower()):
            group_items = grouped_entries[group_name]
            group_menu = hydromodelsMenu.addMenu(f"{group_name} ({len(group_items)})")
            for long_name, names, model_id in sorted(group_items, key=lambda item: item[0].lower()):
                group_menu.addAction(
                    long_name,
                    lambda checked=False, ln=long_name, layernames=tuple(names), mid=model_id, wms_url=url: self.addHydromodelLayers(ln, list(layernames), wms_url, mid)
                )


    def refreshLayersMenu(self):
        debugMsg("Refreshing layer catalogue")
        if not hasattr(self, 'layersMenu') or self.layersMenu is None:
            debugMsg("  Layer menu handle unavailable; rebuilding full menu")
            self.reloadMenu()
            return

        self.layersMenu.clear()
        self.layersMenu.setTitle('Add layers to map')
        self.populateLayersMenu(self.layersMenu)


    def refreshHydromodelsMenu(self):
        debugMsg("Refreshing hydromodel catalogue")
        if not hasattr(self, 'hydromodelsMenu') or self.hydromodelsMenu is None:
            debugMsg("  Hydromodel menu handle unavailable; rebuilding full menu")
            self.reloadMenu()
            return

        self.populateHydromodelsMenu(self.hydromodelsMenu)


    def update_GAL_layers_with_tokens(self):
        debugMsg("Updating Tokens.")
        self.apiKey = self.apiKeyGetter.getApiKey() # update key
        self.ensureElemDict()
        
        token_regex = r'(&|%26)?token([=:]|%3A|%3D)(?P<Token>[\d\w\.=+-_\/]*)'
        #Find all layers with tokens in them, which are updatable and created by us.
        for layer in self.iface.mapCanvas().layers():
            if not layer.name().startswith("GAL"):
                continue
            if not type(layer) is QgsRasterLayer:
                continue
            if not callable(getattr(layer, "dataProvider", None)):
                continue    
            if not callable(getattr(layer.dataProvider(), "dataSourceUri", None)):
                continue
            uri = layer.dataProvider().dataSourceUri()
            token =  re.search(token_regex, uri)
            if not token:
                continue
            token = token.group('Token')
            # make sure the function exists, else we crash
            if callable(getattr(layer, "setDataSource", None)):
                debugMsg("  Updated Token for layer: " + layer.name())
                uri = uri.replace(token, self.apiKeyGetter.getApiKeyNoBearer())
                layer.setDataSource(uri, layer.name(), 'wms', QgsDataProvider.ProviderOptions()) 



    def addActionsToActionBar(self):
        # The action menu bar. 
        crosstool = QAction(QIcon( self.plugin_dir + "/images/cross.png"), 'Get profile of existing line', self.iface.mainWindow())
        crosstool.triggered.connect(self.crosssectionTool.crossectionExistingLine)
        self.myToolBar.addAction(crosstool)
        crosstool2 = QAction(QIcon( self.plugin_dir + "/images/crossNew.png"), 'Get profile of new line', self.iface.mainWindow())
        crosstool2.triggered.connect(self.crosssectionTool.createNewLineAndCrossSection)
        self.myToolBar.addAction(crosstool2)
        slicetool = QAction(QIcon( self.plugin_dir + "/images/slice.png"), 'Open Slice view', self.iface.mainWindow())
        slicetool.triggered.connect(self.sliceTool.startSliceTool)
        self.myToolBar.addAction(slicetool)
        boretool = QAction(QIcon( self.plugin_dir + "/images/bore.png"), 'Make virtual borehole', self.iface.mainWindow())
        boretool.triggered.connect(self.virtualBoring.changeToBoringTool)
        self.myToolBar.addAction(boretool)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.makeMenu()
        # will be set False in run()
        self.first_start = True

    def unload(self):
        self.clearMenu()
        
    def helpmessagebox(self):
        msgBox = QMessageBox()
        msgBox.setWindowTitle( "Help" )
        msgBox.setTextFormat( Qt.RichText )
        msgBox.setText( "<br>We have two manuals to help you along<br>" 
            + "GeoAtlasLive Manual: <a href='{0}'>{0}</a><br><br>".format("https://wgn.geo.dk/geodata/GeoAtlasLive_Manual.pdf")
            + "Plugin Manual: <a href='{0}'>{0}</a><br><br>".format("https://wgn.geo.dk/geodata/GeoAtlasPlugin_Manual.pdf"))

        msgBox.setStandardButtons( QMessageBox.Ok )
        msgBox.exec_() 

    def aboutmessagebox(self):
        title = "About"
        message = "QGIS implementation of GeoAtlasLive\n"
        message += "Version 1.3\n"
        message += "Copyright (c) 2022 GEO\n"
        message += "data@geo.dk"
        QMessageBox.information(self.iface.mainWindow(), title, message)

    def reloadMenu(self):
        self.clearMenu()
        self.makeMenu()
    
    def clearMenu(self):
        if self.myToolBar:
            self.iface.mainWindow().removeToolBar(self.myToolBar)
            self.myToolBar = None
        if self.menu:
            self.iface.mainWindow().menuBar().removeAction(self.menu.menuAction())
            self.menu.deleteLater()
            self.menu = None
        self.layersMenu = None
        self.hydromodelsMenu = None

    def addLayer(self, title, layername, style="", custom_url=None):
        if self.apiKeyGetter.getApiKey() is None:
            return

        self.ensureElemDict()
        debugMsg(f"Adding layer: '{title}' | Layer: '{layername}' | Style: '{style}'")

        if ',' in layername:
            layer_names = [ln.strip() for ln in layername.split(',')]
            debugMsg(f"  Detected multiple layers: {layer_names}")
            styles = [s.strip() for s in style.split(',')] if style and ',' in style else [style] * len(layer_names)
            debugMsg(f"  Using styles: {styles}")
            
            root = QgsProject.instance().layerTreeRoot()
            gal_group = root.findGroup('GAL') or root.insertGroup(0, 'GAL')
            subgroup = gal_group.insertGroup(0, title)
            
            for layer_name, layer_style in zip(layer_names, styles):
                display_name = layer_name.split(':')[-1] if ':' in layer_name else layer_name
                uri = self.makeWmsUri(layer_name, layer_style, custom_url)
                debugMsg(f"    Adding sub-layer: '{display_name}' | Layer: '{layer_name}' | Style: '{layer_style}'")
                layer = QgsRasterLayer(uri, display_name, "wms")
                
                QgsProject.instance().addMapLayer(layer, False)
                layer_node = subgroup.addLayer(layer)
                if not layer.isValid():
                    error_msg = layer.dataProvider().error().message() if layer.dataProvider() else "No provider"
                    debugMsg(f"    Sub-layer '{display_name}' is not valid")
                    debugMsg(f"      Layer Name: {layer_name} | Style: {layer_style}")
                    debugMsg(f"      URI: {uri}")
                    debugMsg(f"      Provider Error: {error_msg}")
                    debugMsg(f"      Check the network logger or read above for more information.")
                    if layer_node:
                        layer_node.setItemVisibilityChecked(False)
                else:
                    debugMsg(f"      URI: {uri}")
                    debugMsg(f"    Sub-layer '{display_name}' added successfully")
                    layer.triggerRepaint()
        else:
            uri = self.makeWmsUri(layername, style, custom_url)
            layer = QgsRasterLayer(uri, title, "wms")
            
            QgsProject.instance().addMapLayer(layer, False)
            layer_node = add_layer_to_group(layer, 'GAL')
            if not layer.isValid():
                error_msg = layer.dataProvider().error().message() if layer.dataProvider() else "No provider"
                debugMsg(f"    Layer '{title}' is not valid")
                debugMsg(f"      Layer Name: {layername} | Style: {style}")
                debugMsg(f"      URI: {uri}")
                debugMsg(f"      Provider Error: {error_msg}")
                debugMsg(f"      Check the network logger or read above for more information.")
                if layer_node:
                    layer_node.setItemVisibilityChecked(False)
            else:
                debugMsg(f"      URI: {uri}")
                debugMsg(f"Layer '{title}' added successfully")
                layer.triggerRepaint()


    def addHydromodelLayers(self, title, layer_names, custom_url, model_id):
        if self.apiKeyGetter.getApiKey() is None:
            return

        layer_names = [ln for ln in (layer_names or []) if ln]
        if not layer_names:
            return

        self.ensureElemDict()
        debugMsg(f"Adding hydromodel: '{title}' | Layers: {layer_names} | ModelId: {model_id}")

        comma_layers = ','.join(layer_names)
        self.addLayer(title, comma_layers, "", custom_url)

        root = QgsProject.instance().layerTreeRoot()
        subgroup = None
        gal_group = None
        if root:
            gal_group = root.findGroup('GAL')
            if gal_group:
                subgroup = gal_group.findGroup(title)

        parent_group = subgroup or gal_group
        points_param = f"ids:{model_id}"
        points_uri = self.makeWmsUri(
            'hydromodel-points',
            '',
            custom_url,
            extra_params={'viewparams': points_param}
        )
        points_display_name = 'hydromodel-points'
        debugMsg(f"    Adding hydromodel points layer with VIEWPARAMS '{points_param}'")
        points_layer = QgsRasterLayer(points_uri, points_display_name, "wms")

        QgsProject.instance().addMapLayer(points_layer, False)
        points_node = None
        if parent_group:
            points_node = parent_group.addLayer(points_layer)
        else:
            points_node = add_layer_to_group(points_layer, 'GAL')

        if not points_layer.isValid():
            error_msg = points_layer.dataProvider().error().message() if points_layer.dataProvider() else "No provider"
            debugMsg("    Hydromodel points layer is not valid")
            debugMsg(f"      URI: {points_uri}")
            debugMsg(f"      Provider Error: {error_msg}")
            debugMsg(f"      Check the network logger or read above for more information.")
            if points_node:
                points_node.setItemVisibilityChecked(False)
        else:
            debugMsg(f"      URI: {points_uri}")
            debugMsg("    Hydromodel points layer added successfully")
            points_layer.triggerRepaint()


    def makeWmsUri(self, layername, style, custom_url=None, extra_params=None):
        layername = (layername or '').strip()
        style = (style or '').strip()
        extra_params = extra_params or {}

        def should_ignore_style(style_value):
            if not style_value:
                return True
            style_lower = style_value.lower()
            if ':' in style_lower:
                style_lower = style_lower.split(':', 1)[1]
            return style_lower in ['[empty]', 'none', '']

        if should_ignore_style(style):
            style = ''

        quri = QgsDataSourceUri()
        quri.setParam("IgnoreGetFeatureInfoUrl", '1')
        quri.setParam("IgnoreGetMapUrl", '1')
        quri.setParam("contextualWMSLegend", '0')
        quri.setParam("crs", 'EPSG:25832')
        quri.setParam("dpiMode", '7')
        quri.setParam("featureCount", '10')
        quri.setParam("format", 'image/png')
        quri.setParam("transparent", 'true')

        if custom_url:
            url = self._ensure_auth(custom_url)
        else:
            base_url = self.settings.get_geo_base_url()
            default_url = f'{base_url}/mapv2/GEO-Services/wms?VERSION=1.3.0&CRS=EPSG%3A25832'
            url = self._ensure_auth(default_url)

        if extra_params:
            try:
                parsed_extra = urllib.parse.urlparse(url)
                query_items = urllib.parse.parse_qsl(parsed_extra.query, keep_blank_values=True)
                for key, value in extra_params.items():
                    if value in (None, ''):
                        continue
                    query_items = [item for item in query_items if item[0].lower() != str(key).lower()]
                    query_items.append((key, value))
                url = urllib.parse.urlunparse(parsed_extra._replace(query=urllib.parse.urlencode(query_items, doseq=True)))
            except ValueError:
                pass

        layername = self._normalize_layer_name(url, layername)
        style = self._normalize_layer_name(url, style) if style else ''

        quri.setParam("layers", layername)
        quri.setParam("styles", style)
        quri.setParam("url", url)
        return str(quri.encodedUri())[2:-1]

    def _ensure_auth(self, url):
        if not url:
            return url
        auth = None
        parsed_url = urllib.parse.urlparse(url)
        host = parsed_url.netloc.lower()
        
        if 'geo.dk' in host:
            auth = {"token": self.apiKeyGetter.getApiKeyNoBearer()}

        if 'dataforsyningen.dk' in host:
            auth = {"token": self.settings.value('dataforsyningen_token')}
            
        if 'datafordeler.dk' in host:
            auth = {"username": self.settings.value('datafordeler_username'),
                    "password": self.settings.value('datafordeler_password')}
            
        if auth:
            query_items = urllib.parse.parse_qsl(parsed_url.query, keep_blank_values=True)
            for key, value in auth.items():
                if value in (None, ''):
                    continue
                query_items = [item for item in query_items if item[0].lower() != key.lower()]
                query_items.append((key, value))
            if query_items:
                new_query = urllib.parse.urlencode(query_items, doseq=True)
                return urllib.parse.urlunparse(parsed_url._replace(query=new_query))
        
        return url

    def _normalize_layer_name(self, url, layername, silent=False):
        if not layername or not url:
            return layername

        try:
            parsed = urllib.parse.urlparse(url)
        except ValueError:
            return layername

        service_url = urllib.parse.urlunparse((parsed.scheme, parsed.netloc, parsed.path, '', '', ''))
        query_pairs = urllib.parse.parse_qsl(parsed.query, keep_blank_values=True)

        filtered_params = []
        has_service = False
        for key, value in query_pairs:
            if key.lower() == 'request':
                continue
            filtered_params.append((key, value))
            if key.lower() == 'service':
                has_service = True

        if not has_service:
            filtered_params.append(('SERVICE', 'WMS'))

        filtered_params.append(('REQUEST', 'GetCapabilities'))
        capability_query = urllib.parse.urlencode(filtered_params, doseq=True)
        capability_url = service_url
        if capability_query:
            capability_url = f"{service_url}?{capability_query}"

        available_names = self._get_capability_layer_names(capability_url)
        if not available_names:
            return layername

        target_lower = layername.lower()
        suffix_lower = target_lower.split(':', 1)[-1]

        for candidate in available_names:
            if candidate.lower() == target_lower:
                if not silent:
                    debugMsg(f"    Using capability layer name '{candidate}' for request '{layername}'")
                return candidate

        suffix_matches = []
        for candidate in available_names:
            candidate_suffix = candidate.split(':', 1)[-1]
            if candidate_suffix.lower() == suffix_lower:
                suffix_matches.append(candidate)

        if suffix_matches:
            if ':' in layername:
                original_prefix = layername.split(':', 1)[0].lower()
                for candidate in suffix_matches:
                    if ':' in candidate and candidate.split(':', 1)[0].lower() == original_prefix:
                        if not silent:
                            debugMsg(f"    Using capability layer name '{candidate}' for request '{layername}'")
                        return candidate
            suffix_matches.sort(key=len)
            chosen = suffix_matches[0]
            if not silent:
                debugMsg(f"    Using capability layer name '{chosen}' for request '{layername}'")
            return chosen

        return layername

    def _get_capability_layer_names(self, capability_url):
        cached = self._capabilities_cache.get(capability_url)
        if cached is not None:
            return cached

        try:
            response = requests.get(capability_url, timeout=10)
            response.raise_for_status()
        except requests.RequestException as exc:
            host = urllib.parse.urlparse(capability_url).netloc
            debugMsg(f"    Could not load capabilities from '{host}': {exc}")
            return []

        try:
            root = ET.fromstring(response.content)
        except ET.ParseError as exc:
            host = urllib.parse.urlparse(capability_url).netloc
            debugMsg(f"    Failed to parse capabilities from '{host}': {exc}")
            return []

        names = []
        for name_elem in root.findall('.//{*}Layer/{*}Name'):
            name_text = (name_elem.text or '').strip()
            if name_text:
                names.append(name_text)

        if names:
            host = urllib.parse.urlparse(capability_url).netloc
            debugMsg(f"    Discovered {len(names)} layer name(s) from '{host}' capabilities")

        self._capabilities_cache[capability_url] = names
        return names

    def addModelsToMap(self, createonlyfile = False):
        if createonlyfile: debugMsg("Creating models.json file")
        else: debugMsg("Adding models to map")
        base_url = self.settings.get_geo_base_url()
        r = requests.get(f"{base_url}/api/v3/geomodel?geoareaid=1&format=geojson", headers={'authorization': self.apiKeyGetter.getApiKey()})
        json = r.content.decode('utf-8').replace('\\"', '"')[1:-1]
        
        tmppath = str(tempfile.gettempdir()) + os.sep + "GeoAtlas" + os.sep
        if not os.path.exists(tmppath):
            os.makedirs(tmppath)

        file = open(tmppath + "models.json", "w")
        file.write(json)
        jsonpath = os.path.realpath(file.name)
        file.close()

        if not createonlyfile:
            vlayer = QgsVectorLayer(jsonpath,"GAL - Models", "ogr")
            vlayer.setCrs(QgsCoordinateReferenceSystem("EPSG:25832")) # needs to be done to make sure its not displayed in some other default CRS
            
            if vlayer.isValid():
                
                #Set style with: vlayer.renderer().symbol().symbolLayers()[0].
                #Documented here: https://qgis.org/api/classQgsSimpleFillSymbolLayer.html
                #Remove fill and only have outline.
                vlayer.renderer().symbol().symbolLayers()[0].setBrushStyle(0)
                QgsProject.instance().addMapLayer(vlayer, False)
                add_layer_to_group(vlayer)
        if self.elemdict is None:
            self.createElemDict()

    def createElemDict(self):

        tmppath = str(tempfile.gettempdir()) + os.sep + "GeoAtlas" + os.sep
        if not os.path.exists(tmppath):
            os.makedirs(tmppath)
        
        fh = open(tmppath + 'models.json', encoding='utf-8')
        tree = json.load(fh)
        ETdict = {}

        for child in tree["features"]:
            id = child['properties']['Id']
            type = child['geometry']['type']
            coordlist = child['geometry']['coordinates']
            if type == 'MultiPolygon':
                coordlist = [item for sublist in coordlist for item in sublist] #flatten one level
            ETdict[id] = coordlist
        
        self.elemdict = ETdict
        fh.close()


    def ensureElemDict(self):
        if self.apiKeyGetter.getApiKey() is None:
            return

        model_path = str(tempfile.gettempdir()) + os.sep + "GeoAtlas" + os.sep + 'models.json'
        if not os.path.exists(model_path) or os.path.getsize(model_path) < 5000:
            #update models if doesn't exist or under 5kb
            self.addModelsToMap(createonlyfile=True)
        if self.elemdict is None and os.path.getsize(model_path) > 5000:
            # create if doesn't exist and model.json is larger than 5kb
            self.createElemDict()
